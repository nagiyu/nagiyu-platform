# データベース設計パターン

## 目的

本ドキュメントは、新規サービス設計時のデータベース選択をサポートするため、プラットフォームで採用可能なデータベース設計パターンを定義する。各パターンの思想、メリット・デメリット、適用ケースを明確にし、適切なパターン選択を支援する。

---

## 1. データベース設計の考え方

### 設計の出発点

データベース設計は、以下の順序で検討することを推奨する：

1.  **アクセスパターンの特定**
    - どのようなクエリが実行されるか
    - どのデータが一緒に取得されるか
    - 読み取りと書き込みの頻度と比率

2.  **データの関連性と境界**
    - エンティティ間の関連性（1対1、1対多、多対多）
    - トランザクション境界（どのデータが原子性を必要とするか）
    - データの一貫性要件

3.  **スケーラビリティ要件**
    - 予想されるデータ量とトラフィック
    - 地理的分散の必要性
    - 読み取り/書き込みのスケーリング要件

4.  **パターンの選択**
    - アクセスパターンとデータ特性に基づいて最適なパターンを選択
    - 複雑さとメリットのトレードオフを評価

### 設計の基本原則

- **アクセスパターン優先**: データ構造ではなく、アクセスパターンから設計を始める
- **シンプルさ重視**: 必要以上に複雑な設計を避ける
- **パフォーマンス**: 最も頻繁なクエリを最適化する
- **コスト効率**: スループットとストレージのコストを考慮する
- **将来の拡張性**: 初期段階で完璧を目指さず、段階的に改善できる設計を選ぶ

---

## 2. DynamoDB Single Table Design パターン

### 2.1 パターンの説明（思想・コンセプト）

Single Table Design は、複数のエンティティタイプを1つのDynamoDBテーブルに格納する設計パターンである。

**中核となる思想**:

- **アクセスパターンの事前設計**: テーブル設計時に全てのアクセスパターンを洗い出し、それを満たすようにPK/SKを設計する
- **データの局所性**: 一緒にアクセスされるデータを物理的に近くに配置し、1回のクエリで取得する
- **GSIの戦略的活用**: 異なる視点でのクエリを可能にするため、Global Secondary Index（GSI）を設計する
- **柔軟な階層構造**: PK/SK の命名規則により、エンティティ間の関係と階層を表現する

**基本構造**:

- **PK（Partition Key）**: エンティティのグループ化キー（例: `USER#123`, `TICKER#AAPL`）
- **SK（Sort Key）**: エンティティの識別子または階層（例: `HOLDING#AAPL`, `METADATA`）
- **Type属性**: エンティティタイプの識別（例: `User`, `Holding`, `Watchlist`）
- **GSI**: 異なるアクセスパターンをサポートするための追加インデックス

**設計例（概念）**:

```
PK                  SK                  Type        その他の属性
----------------------------------------------------------------------
USER#123            METADATA            User        Name, Email, ...
USER#123            HOLDING#AAPL        Holding     Quantity, AvgPrice, ...
USER#123            HOLDING#GOOGL       Holding     Quantity, AvgPrice, ...
USER#123            WATCHLIST#tech      Watchlist   Name, Description, ...
TICKER#AAPL         METADATA            Ticker      Symbol, Name, Exchange, ...
TICKER#AAPL         ALERT#daily         Alert       Frequency, Threshold, ...
```

### 2.2 メリット・デメリット

#### メリット

1.  **高いクエリ効率**
    - 関連するデータを1回のクエリで取得可能（Joinが不要）
    - DynamoDBの強い一貫性読み取りを最大限活用
    - 予測可能なレイテンシとスループット

2.  **コスト効率**
    - 1つのテーブルのため、プロビジョニングコストが集約される
    - オンデマンドモードでもコストが分散しない
    - ストレージコストの最適化

3.  **スケーラビリティ**
    - DynamoDBの自動スケーリング機能をフルに活用
    - ホットパーティションの回避が容易（適切なPK設計により）
    - 地理的分散（グローバルテーブル）が1テーブルで完結

4.  **柔軟性**
    - 新しいエンティティタイプの追加が容易
    - アクセスパターンの追加にGSIで対応可能
    - スキーマレスの利点を最大限活用

#### デメリット

1.  **設計の複雑性**
    - 初期設計で全てのアクセスパターンを洗い出す必要がある
    - PK/SKの命名規則とGSI設計に高度な知識が必要
    - 新規参加者への学習コストが高い

2.  **変更の困難性**
    - アクセスパターンの大幅な変更には、データマイグレーションが必要
    - GSIの追加は可能だが、既存データへのバックフィルが必要
    - 設計ミスの修正コストが高い

3.  **クエリの制約**
    - 事前に設計されたアクセスパターンのみが効率的
    - アドホッククエリや複雑な検索は困難
    - リレーショナルデータベースのような柔軟なクエリは不可能

4.  **運用の複雑性**
    - 複数エンティティが混在するため、デバッグが困難
    - データの可視化ツールでの表示が複雑
    - 誤って異なるエンティティタイプを操作するリスク

### 2.3 適用すべきケース・避けるべきケース

#### 適用すべきケース

1.  **明確で固定的なアクセスパターン**
    - 事前に全てのクエリパターンが定義できる
    - アクセスパターンが安定しており、頻繁に変わらない
    - 特定のユースケースに最適化されたアプリケーション

2.  **高いパフォーマンス要件**
    - 低レイテンシが求められる（数ミリ秒単位）
    - 高いスループットが必要（数万リクエスト/秒以上）
    - 予測可能なパフォーマンスが重要

3.  **関連データの頻繁な同時取得**
    - ユーザーとその関連データ（設定、プロフィール、アクティビティ等）を一緒に取得
    - 親子関係のデータを同時に取得する必要がある
    - 1つのビューで複数エンティティを表示する

4.  **コスト最適化が重要**
    - 複数テーブルのプロビジョニングコストを削減したい
    - オンデマンドモードでのコスト効率を最大化したい
    - グローバルテーブルのコストを抑えたい

5.  **スケーラビリティが重要**
    - 大量のデータと高トラフィックが予想される
    - 地理的に分散したユーザーベース
    - 自動スケーリングを最大限活用したい

#### 避けるべきケース

1.  **アクセスパターンが不明確または頻繁に変わる**
    - 要件が流動的で、将来のクエリパターンが予測できない
    - 探索的なデータ分析が必要
    - アドホッククエリが頻繁に実行される

2.  **複雑なリレーショナルクエリが必要**
    - 多対多の関係が多数存在する
    - 複雑なJOINや集計が必要
    - SQLライクな柔軟なクエリが必要

3.  **チームのDynamoDB経験が少ない**
    - Single Table Design の学習コストが高すぎる
    - 迅速な開発が求められ、学習時間を確保できない
    - チーム全体での設計理解が困難

4.  **シンプルさが最優先**
    - エンティティ間の関連性が低い
    - 各エンティティが独立してアクセスされる
    - 設計の複雑さを避けたい

5.  **トランザクション要件が複雑**
    - 複数エンティティにまたがる複雑なトランザクション
    - 厳密な整合性保証が必要（DynamoDBトランザクションの制約を超える）

### 2.4 設計原則

#### PK/SK 命名の考え方

**基本原則**:

- **プレフィックスの使用**: エンティティタイプを識別するプレフィックスを付ける（例: `USER#`, `TICKER#`, `ORDER#`）
- **階層的な構造**: SKで親子関係や階層を表現する（例: `HOLDING#AAPL`, `METADATA`）
- **可読性**: 人間が読んで理解できる命名（デバッグやメンテナンスのため）
- **一貫性**: 全エンティティで統一された命名規則を適用

**命名パターン**:

1.  **エンティティの主キー**
    - PK: `{ENTITY_TYPE}#{ID}` （例: `USER#123`, `PRODUCT#SKU456`）
    - SK: `METADATA` または `INFO`（エンティティ自体を表す）

2.  **1対多の関係**
    - PK: 親エンティティのID（例: `USER#123`）
    - SK: 子エンティティタイプとID（例: `ORDER#2024-001`, `POST#20240101-001`）

3.  **多対多の関係**
    - PK: 一方のエンティティID（例: `USER#123`）
    - SK: 他方のエンティティタイプとID（例: `GROUP#developers`）
    - 逆方向のクエリのためにGSIを使用

4.  **時系列データ**
    - PK: エンティティID（例: `SENSOR#temp001`）
    - SK: タイムスタンプ（例: `2024-01-15T10:30:00Z` または `20240115103000`）
    - 範囲クエリを活用して期間を指定

**避けるべき命名**:

- ランダムなUUIDをPKに使用（ホットパーティションを引き起こす可能性）
- 長すぎる文字列（ストレージとネットワークコストの増加）
- 特殊文字の多用（デバッグ時の可読性低下）

#### GSI 設計の考え方

**GSIの役割**:

- メインテーブルとは異なる視点でのクエリを可能にする
- 新しいアクセスパターンを後から追加できる柔軟性を提供
- データの冗長性を活用して読み取りパフォーマンスを最適化

**設計原則**:

1.  **明確な目的**: 各GSIが解決する特定のアクセスパターンを明確にする
2.  **最小限の数**: GSIは書き込みコストを増加させるため、必要最小限に抑える（推奨: 3-5個以内）
3.  **Sparse Index の活用**: 全てのアイテムにGSI属性を持たせず、必要なものだけに付与してコスト削減
4.  **射影属性の最適化**: 必要な属性のみを射影してストレージコストを削減

**一般的なGSIパターン**:

1.  **逆引きインデックス**
    - 目的: PK/SKを逆にした検索を可能にする
    - 例: メインテーブルが `USER#123` → `HOLDING#AAPL` なら、GSIで `TICKER#AAPL` → `USER#123` を検索可能に

2.  **ステータスインデックス**
    - 目的: 特定の状態のアイテムを効率的に検索
    - 例: `STATUS#pending` → `ORDER#2024-001` で未処理の注文を取得

3.  **時系列インデックス**
    - 目的: 作成日時や更新日時での検索
    - 例: `TYPE#Order` → `2024-01-15T10:30:00Z` で最近の注文を取得

4.  **カテゴリインデックス**
    - 目的: カテゴリやタイプでのグルーピングと検索
    - 例: `CATEGORY#electronics` → `PRODUCT#123` でカテゴリ別の商品を取得

**GSI設計のベストプラクティス**:

- GSIのPKには十分なカーディナリティ（多様性）を持たせる
- 書き込みホットスポットを避けるため、PKを工夫する
- 必要に応じてGSI専用の属性を追加（例: `GSI1PK`, `GSI1SK`）
- GSIのスループット設定を適切に行う（オンデマンドモードまたはプロビジョニング）

#### アクセスパターン設計の思想

**設計プロセス**:

1.  **アクセスパターンの網羅的な洗い出し**
    - 全てのユーザーストーリーからクエリを特定
    - 読み取りと書き込みの両方をリストアップ
    - 頻度と重要度を評価

2.  **パターンの優先順位付け**
    - 最も頻繁なクエリ: メインテーブルのPK/SKで最適化
    - 2番目に重要なクエリ: GSI1で対応
    - それ以降: 追加のGSIまたはスキャン+フィルタで対応

3.  **PK/SK設計の決定**
    - 最重要アクセスパターンを満たすPK/SKを設計
    - 複数エンティティを同じパーティションに配置するか判断
    - SKでのソート順が有用かを検討

4.  **GSI設計の決定**
    - メインテーブルで対応できないパターンをGSIで解決
    - 各GSIの目的とカバーするアクセスパターンを文書化
    - Sparse Indexの活用を検討

5.  **検証とイテレーション**
    - プロトタイプを作成して全アクセスパターンをテスト
    - パフォーマンスとコストを測定
    - 必要に応じて設計を調整

**設計時の考慮事項**:

- **読み取りの最適化**: DynamoDBは読み取りが速いため、データの冗長性を許容して読み取りを最適化
- **書き込みの集約**: 関連データを同じパーティションに配置し、トランザクション書き込みを容易にする
- **ホットパーティションの回避**: PKに十分な分散性を持たせる（例: ユーザーIDをPKに使用）
- **将来の拡張性**: 後からGSIを追加できることを念頭に、初期設計をシンプルに保つ

**避けるべきアンチパターン**:

- 全てのクエリを満たそうとして過度に複雑な設計にする
- アドホッククエリのためにScanを前提とした設計
- GSIを過剰に作成して書き込みコストを増大させる
- アクセスパターンの優先順位を付けずに設計を開始する

---

## 3. DynamoDB 複数テーブル設計パターン

### 3.1 パターンの説明

複数テーブル設計は、各エンティティタイプを独立したDynamoDBテーブルに格納する、より従来的な設計パターンである。

**中核となる思想**:

- **エンティティの独立性**: 各エンティティは専用のテーブルを持ち、独立して管理される
- **シンプルさ優先**: PK/SK設計がシンプルで、理解しやすい
- **テーブルごとの最適化**: 各テーブルのスループット、バックアップ、TTL等を個別に設定可能
- **段階的な設計**: 初期段階で全てのアクセスパターンを洗い出す必要がない

**基本構造**:

各エンティティが専用のテーブルを持つ：

- **Usersテーブル**: PK = `UserID`
- **Holdingsテーブル**: PK = `UserID`, SK = `TickerID`
- **Watchlistsテーブル**: PK = `UserID`, SK = `WatchlistID`
- **Tickersテーブル**: PK = `TickerID`
- **Alertsテーブル**: PK = `AlertID` または PK = `UserID`, SK = `AlertID`

**設計例（概念）**:

```
Users テーブル:
PK (UserID)     属性
--------------------------------
123             Name, Email, CreatedAt, ...

Holdings テーブル:
PK (UserID)     SK (TickerID)   属性
---------------------------------------------------
123             AAPL            Quantity, AvgPrice, ...
123             GOOGL           Quantity, AvgPrice, ...

Tickers テーブル:
PK (TickerID)   属性
-----------------------------------
AAPL            Symbol, Name, Exchange, ...
GOOGL           Symbol, Name, Exchange, ...
```

### 3.2 メリット・デメリット

#### メリット

1.  **シンプルで理解しやすい**
    - 各テーブルが1つのエンティティタイプのみを保存
    - リレーショナルデータベースに近い考え方で設計可能
    - 新規参加者への学習コストが低い

2.  **柔軟な設計変更**
    - 各テーブルを独立して変更可能
    - 新しいエンティティの追加が容易
    - 既存テーブルへの影響なく新テーブルを作成できる

3.  **個別の最適化**
    - テーブルごとにスループット設定を調整可能
    - テーブルごとに異なるバックアップポリシーを設定
    - TTL、ストリーム、暗号化などを個別に設定

4.  **運用のシンプルさ**
    - 各テーブルを独立して監視・メンテナンス可能
    - デバッグとトラブルシューティングが容易
    - データの可視化ツールでの表示がわかりやすい

5.  **段階的な設計**
    - 初期段階で全てのアクセスパターンを決定する必要がない
    - 要件の変化に柔軟に対応できる
    - プロトタイプやMVPの構築が迅速

#### デメリット

1.  **クエリ効率の低下**
    - 複数テーブルからデータを取得する場合、複数のクエリが必要
    - Joinができないため、アプリケーション側で結合処理が必要
    - レイテンシが増加する可能性

2.  **コストの増加**
    - 複数テーブルのプロビジョニングコストが発生
    - オンデマンドモードでも各テーブルで最小料金が発生する可能性
    - グローバルテーブルの場合、レプリケーションコストが倍増

3.  **データの一貫性管理**
    - 複数テーブルにまたがるトランザクションは複雑（最大100アイテム、25テーブルの制約）
    - 結果整合性を受け入れるか、複雑なトランザクション管理が必要
    - 参照整合性の維持がアプリケーション側の責任

4.  **スケーラビリティの課題**
    - 関連データの取得に複数のクエリが必要で、スケーラビリティに影響
    - N+1クエリ問題が発生しやすい
    - キャッシュ戦略が複雑化

### 3.3 適用すべきケース

#### 適用すべきケース

1.  **エンティティ間の関連性が低い**
    - 各エンティティが独立してアクセスされる
    - クロスエンティティのクエリが少ない
    - エンティティごとに異なるアクセスパターン

2.  **シンプルさと開発スピードが重要**
    - 迅速なプロトタイプやMVPの構築
    - チームのDynamoDB経験が少ない
    - 設計の複雑さを最小限に抑えたい

3.  **エンティティごとに異なる要件**
    - テーブルごとに異なるスループット要件
    - エンティティごとに異なるバックアップ頻度
    - TTL、ストリーム、暗号化などの設定が異なる

4.  **段階的な開発**
    - 要件が流動的で、将来の変更が予想される
    - 初期段階で全てのアクセスパターンが明確でない
    - イテレーティブな開発アプローチ

5.  **マイクロサービスアーキテクチャ**
    - 各マイクロサービスが独自のテーブルを持つ
    - サービス間の疎結合を維持したい
    - 各サービスが独立してスケールする必要がある

#### 避けるべきケース

1.  **頻繁なクロスエンティティクエリ**
    - 複数エンティティを同時に取得するクエリが多い
    - Joinライクな操作が頻繁に必要
    - 低レイテンシが求められる

2.  **コスト最適化が最優先**
    - 複数テーブルのプロビジョニングコストが問題になる
    - グローバルテーブルでのレプリケーションコストを最小化したい
    - 少数のテーブルで全てを管理したい

3.  **厳密なトランザクション要件**
    - 複数テーブルにまたがる複雑なトランザクションが多い
    - 厳密な整合性保証が必要
    - DynamoDBトランザクションの制約を超える要件

---

## 4. パターン選択ガイドライン

### いつ Single Table を選ぶか

以下の条件が**複数**当てはまる場合、Single Table Designを検討する：

1.  **アクセスパターンが明確**
    - 全ての主要なクエリパターンが事前に定義できる
    - 要件が安定しており、大幅な変更が予想されない

2.  **パフォーマンスが最優先**
    - 低レイテンシ（1桁ミリ秒）が必須
    - 高スループット（数万リクエスト/秒以上）が必要

3.  **関連データの頻繁な同時取得**
    - ユーザーとその関連データを一緒に取得する必要がある
    - 親子関係のデータを1回のクエリで取得したい

4.  **コスト効率が重要**
    - 複数テーブルのコストを削減したい
    - グローバルテーブルのレプリケーションコストを最小化したい

5.  **チームに十分な専門知識**
    - DynamoDBとSingle Table Designの経験がある
    - 設計の複雑さを管理できる体制がある

### いつ複数テーブルを選ぶか

以下の条件が**複数**当てはまる場合、複数テーブル設計を検討する：

1.  **要件が流動的**
    - 将来のアクセスパターンが不明確
    - 頻繁な要件変更が予想される
    - 探索的な開発フェーズにある

2.  **シンプルさ優先**
    - チームのDynamoDB経験が少ない
    - 迅速な開発とプロトタイプ構築が必要
    - 学習コストを最小限に抑えたい

3.  **エンティティの独立性が高い**
    - 各エンティティが独立してアクセスされる
    - クロスエンティティのクエリが少ない
    - エンティティごとに異なる要件がある

4.  **個別の最適化が必要**
    - テーブルごとに異なるスループット設定
    - エンティティごとに異なるバックアップやTTL設定
    - 段階的なスケーリングが必要

5.  **マイクロサービスアーキテクチャ**
    - 各サービスが独自のデータストアを持つ
    - サービス間の疎結合を維持したい

### 判断基準

以下の表を参考に、プロジェクトの特性に応じて判断する：

| 判断軸                       | Single Table が有利                              | 複数テーブル が有利                          |
| ---------------------------- | ------------------------------------------------ | -------------------------------------------- |
| **アクセスパターンの明確性** | 事前に全て定義可能                               | 不明確または頻繁に変わる                     |
| **パフォーマンス要件**       | 低レイテンシ・高スループット必須                 | 中程度のパフォーマンスで十分                 |
| **クエリの複雑性**           | 関連データの同時取得が多い                       | 各エンティティが独立してアクセスされる       |
| **コスト感度**               | コスト最適化が重要                               | コストより開発スピード優先                   |
| **チームの専門知識**         | DynamoDB/Single Table に精通                     | DynamoDB 経験が少ない                        |
| **要件の変動性**             | 安定した要件                                     | 流動的で変更が多い                           |
| **開発スピード**             | 初期設計に時間をかけられる                       | 迅速なプロトタイプ構築が必要                 |
| **データの一貫性要件**       | 同じパーティション内のトランザクションで対応可能 | 複数テーブルにまたがるトランザクションが多い |
| **マイクロサービス**         | モノリスまたは密結合なサービス                   | 各サービスが独立したデータストア             |
| **運用の複雑性**             | 複雑な設計を管理できる体制                       | シンプルな運用を優先                         |

### ハイブリッドアプローチ

必ずしも全てを Single Table または全てを複数テーブルにする必要はない。以下のようなハイブリッドアプローチも有効：

- **コアエンティティは Single Table**: 頻繁にアクセスされる関連データを Single Table で管理
- **周辺エンティティは別テーブル**: 独立してアクセスされるデータや、異なる要件を持つデータは別テーブル
- **段階的な移行**: 初期は複数テーブルでスタートし、パフォーマンス要件が明確になった段階で Single Table に移行

### 意思決定のプロセス

1.  **アクセスパターンの洗い出し**: 全ての主要なクエリをリストアップ
2.  **優先順位の設定**: パフォーマンス、コスト、開発スピード等の優先順位を決定
3.  **判断基準表の評価**: 上記の表を使用してプロジェクトを評価
4.  **プロトタイプの作成**: 可能であれば両パターンで小規模なプロトタイプを作成
5.  **チームでの合意形成**: 設計決定をチーム全体で共有し、合意を得る
6.  **文書化**: 選択した理由とトレードオフを文書化（例: ADR - Architecture Decision Record）

---

## 5. 参考資料

### AWS 公式ドキュメント

- [Best Practices for DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html) - DynamoDB設計のベストプラクティス
- [DynamoDB Core Components](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html) - テーブル、アイテム、属性の基本概念
- [Working with Tables and Data in DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html) - テーブル設計と操作
- [Global Secondary Indexes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html) - GSI設計ガイド
- [DynamoDB Transactions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/transactions.html) - トランザクション機能

### DynamoDB 設計に関する記事とトーク

- **Rick Houlihan の re:Invent Talks**:
  - [AWS re:Invent 2018: Amazon DynamoDB Deep Dive: Advanced Design Patterns (DAT401)](https://www.youtube.com/watch?v=HaEPXoXVf2k) - Single Table Design の詳細解説
  - [AWS re:Invent 2019: Data modeling with Amazon DynamoDB (CMY304)](https://www.youtube.com/watch?v=DIQVJqiSUkE) - データモデリングのベストプラクティス
  - [AWS re:Invent 2020: Data modeling with Amazon DynamoDB Part 1 & 2](https://www.youtube.com/results?search_query=reinvent+2020+dynamodb+data+modeling) - より高度なパターン

- [The DynamoDB Book by Alex DeBrie](https://www.dynamodbbook.com/) - DynamoDB 設計の包括的なガイド

### コミュニティリソース

- [Alex DeBrie's Blog](https://www.alexdebrie.com/posts/) - DynamoDB 設計パターンとベストプラクティス
- [AWS DynamoDB Guide](https://www.dynamodbguide.com/) - 実践的なDynamoDB使用ガイド
- [DynamoDB Toolbox](https://github.com/jeremydaly/dynamodb-toolbox) - Single Table Design をサポートするライブラリ

### プラットフォーム内の関連ドキュメント

本プラットフォームで DynamoDB を使用する際は、以下のドキュメントも参照すること：

- **アーキテクチャ方針**: プラットフォーム全体のアーキテクチャ設計思想
- **データアクセス層**: Repository パターンとデータアクセス抽象化の詳細
- **テスト戦略**: DynamoDB を使用したサービスのテスト方針

---

## まとめ

データベース設計パターンの選択は、プロジェクトの成功に大きく影響する重要な決定である。

- **Single Table Design**: 高パフォーマンス、コスト効率、スケーラビリティが重要で、アクセスパターンが明確な場合に最適
- **複数テーブル設計**: シンプルさ、柔軟性、開発スピードが重要で、要件が流動的な場合に最適

どちらのパターンも正解・不正解ではなく、プロジェクトの特性、チームの状況、ビジネス要件に応じて適切に選択することが重要である。判断基準を明確にし、チーム全体で合意形成を図り、選択した理由を文書化することで、長期的に保守可能なシステムを構築できる。
